// This is a script to test the circuit against real Tron data
// and calculate the proving complexity

use alloy_sol_types::{sol, SolType};
use block_header::Raw;
use prost::Message;
use sha2::{Digest, Sha256};
use sp1_core::runtime::SyscallCode;
use sp1_sdk::{ProverClient, SP1Stdin};
use tonic::transport::Channel;
use tonic::Request;

tonic::include_proto!("protocol");

use wallet_client::WalletClient;

/// The ELF (executable and linkable format) file for the Succinct RISC-V zkVM.
///
/// This file is generated by running `cargo prove build` inside the `program` directory.
pub const PROGRAM_ELF: &[u8] = include_bytes!("../../../program/elf/riscv32im-succinct-zkvm-elf");

type TronBlock = sol! {
    tuple(bytes32,uint32,bytes32,uint32)
};

type OrderChain = sol! {
    tuple(bytes32,uint32,address)
};

pub fn hash(data: &[u8]) -> Vec<u8> {
    let mut hasher = Sha256::new();
    hasher.update(data);
    hasher.finalize().to_vec()
}

fn blockprint(prev_blockprint: &[u8; 32], blocks: &[(u32, [u8; 32], u32)]) -> [u8; 32] {
    let mut blockprint = *prev_blockprint;
    for (block_number, tx_root, timestamp) in blocks {
        let data = TronBlock::abi_encode(&(blockprint, block_number, tx_root, timestamp));
        blockprint.copy_from_slice(&hash(&data));
    }
    blockprint
}

async fn get_block_by_number(
    client: &mut WalletClient<Channel>,
    block_number: u32,
) -> Result<(Vec<Vec<u8>>, Raw), Box<dyn std::error::Error>> {
    let request = Request::new(NumberMessage {
        num: block_number as i64,
    });

    let response = client.get_block_by_num2(request).await?;
    let block = response.into_inner();

    Ok((
        block
            .transactions
            .iter()
            .map(|tx| tx.transaction.as_ref().unwrap().encode_to_vec())
            .collect(),
        block.block_header.unwrap().raw_data.unwrap(),
    ))
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Setup the logger.
    sp1_sdk::utils::setup_logger();

    // Setup the prover client.
    let client = ProverClient::new();

    // Setup the inputs.

    let mut stdin = SP1Stdin::new();

    let start_block = 62913164u32;
    let end_block = start_block + 100;

    let channel = Channel::from_shared("http://grpc.trongrid.io:50051")?
        .connect()
        .await?;
    let mut wallet_client = WalletClient::new(channel);

    stdin.write(&0u32); // state_length
    stdin.write(&[0u8; 32]); // order_chain (old)
    stdin.write(&1u32); // order_count
    let (_, raw_data) = get_block_by_number(&mut wallet_client, start_block).await?;
    stdin.write(&(raw_data.timestamp as u32 - 1)); // order 0: timestamp
    stdin.write(&[0xffu8; 20]); // order 0: address
    stdin.write(&start_block); // start_block
    stdin.write(&end_block); // end_block
    stdin.write(&[0u8; 32]); // blockprint (of start_block-1)
    let mut total_txs = 0u64;
    for block in start_block..=end_block {
        let (txs, raw_data) = get_block_by_number(&mut wallet_client, block).await?;
        stdin.write(&(raw_data.timestamp as u32));
        stdin.write(&(txs.len() as u32));
        println!("{}", txs.len());
        total_txs += txs.len() as u64;
        txs.into_iter().for_each(|tx| stdin.write_vec(tx));
    }

    stdin.write(&1000u64); // mcycles_cost

    println!("generating...");

    // Generate the proof.
    let (public_values, execution_report) = client
        .execute(PROGRAM_ELF, stdin)
        .expect("failed to generate proof");
    println!("Successfully executed proof!\n");

    println!("Public values: {:?}", public_values);
    println!("Execution report: {:?}\n", execution_report);

    let block_count = (end_block - start_block) as u64;
    let tic = execution_report.total_instruction_count();
    let tsc = *execution_report
        .syscall_counts
        .get(&SyscallCode::SHA_COMPRESS)
        .unwrap();
    println!(
        "Total txs: {} (avg {}/block)",
        total_txs,
        total_txs / block_count
    );
    println!(
        "Total instructions: {} (avg {}/tx, {}/block)",
        tic,
        tic / total_txs,
        tic / block_count
    );
    println!(
        "Total SHA syscalls: {} (avg {}/tx, {}/block)",
        tsc,
        tsc / total_txs,
        tsc / block_count
    );

    Ok(())
}
