// This is a script to test the circuit against real Tron data
// and calculate the proving complexity

use block_header::Raw;
use prost::Message;
use rand::RngCore;
use sp1_core::runtime::SyscallCode;
use sp1_sdk::{ProverClient, SP1Stdin};
use tonic::transport::Channel;
use tonic::Request;

tonic::include_proto!("protocol");

use wallet_client::WalletClient;

/// The ELF (executable and linkable format) file for the Succinct RISC-V zkVM.
///
/// This file is generated by running `cargo prove build` inside the `program` directory.
pub const PROGRAM_ELF: &[u8] = include_bytes!("../../program/elf/riscv32im-succinct-zkvm-elf");

async fn get_block_by_number(
    client: &mut WalletClient<Channel>,
    block_number: u32,
) -> Result<(Vec<Vec<u8>>, Raw), Box<dyn std::error::Error>> {
    let request = Request::new(NumberMessage {
        num: block_number as i64,
    });

    let response = client.get_block_by_num2(request).await?;
    let block = response.into_inner();

    Ok((
        block
            .transactions
            .iter()
            .map(|tx| tx.transaction.as_ref().unwrap().encode_to_vec())
            .collect(),
        block.block_header.unwrap().raw_data.unwrap(),
    ))
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Setup the logger.
    sp1_sdk::utils::setup_logger();

    // Setup the prover client.
    let client = ProverClient::new();

    // Setup the inputs.

    let mut stdin = SP1Stdin::new();

    let start_block = 62913164u32;
    let end_block = start_block + 100;

    let channel = Channel::from_shared("http://grpc.trongrid.io:50051")?
        .connect()
        .await?;
    let mut wallet_client = WalletClient::new(channel);

    stdin.write(&[0xaeu8; 20]); // my_address
    stdin.write(&0u32); // state_length

    stdin.write(&[0u8; 32]); // order_chain (old)
    let order_count = 100u32;
    stdin.write(&order_count); // order_count

    let mut rng = rand::thread_rng();
    let (_, raw_data) = get_block_by_number(&mut wallet_client, start_block).await?;
    for _ in 0..order_count {
        let mut address = [0u8; 20];
        rng.fill_bytes(&mut address);
        stdin.write(&(raw_data.timestamp as u32 + 10000)); // order: timestamp
        stdin.write(&address); // order: address
    }

    stdin.write(&start_block); // start_block
    stdin.write(&end_block); // end_block
    stdin.write(&[0u8; 32]); // blockprint (of start_block-1)
    stdin.write(&1000u64); // mcycles_cost

    let mut total_txs = 0u64;
    for block in start_block..=end_block {
        let (txs, raw_data) = get_block_by_number(&mut wallet_client, block).await?;

        let timestamp = raw_data.timestamp as u32;
        let tx_count = txs.len() as u32;
        stdin.write(&timestamp);
        stdin.write(&tx_count);
        println!("{}", tx_count);
        total_txs += tx_count as u64;
        txs.into_iter().for_each(|tx| stdin.write_vec(tx));
    }

    println!("generating...");

    // Generate the proof.
    let (public_values, execution_report) = client
        .execute(PROGRAM_ELF, stdin)
        .expect("failed to generate proof");
    println!("Successfully executed proof!\n");

    println!("Public values: {:?}", public_values);
    println!("Execution report: {:?}\n", execution_report);

    let block_count = (end_block - start_block) as u64;
    let tic = execution_report.total_instruction_count();
    let tsc = *execution_report
        .syscall_counts
        .get(&SyscallCode::SHA_COMPRESS)
        .unwrap();
    println!(
        "Total txs: {} (avg {}/block)",
        total_txs,
        total_txs / block_count
    );
    println!(
        "Total instructions: {} (avg {}/tx, {}/block)",
        tic,
        tic / total_txs,
        tic / block_count
    );
    println!(
        "Total SHA syscalls: {} (avg {}/tx, {}/block)",
        tsc,
        tsc / total_txs,
        tsc / block_count
    );

    Ok(())
}
